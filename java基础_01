&与：相当于乘法      1&1     1
|或：相当于加法        1|1       1

短路运算：
&&    第一个为false，则表达式为false
||    第一个为true，则表达式为true


浮点运算中，2个整数不会自动转为浮点数。
24.0/4才变成浮点数

接口是拿来实现的，抽象类是拿来继承的。
接口可以作为类型使用，可以作为参数类型，声明的时候。

引用类型和值类型：
引用类型在存储上与值类型有很大区别。
值类型直接由编译器分配内存。（栈上）

引用类型声明后，编译器只分配一点点栈内存（仅用作记录地址）创建实例后，才分配内存堆上的空间， 堆上空间的地址保存到栈上分配的小片空间中。有一种指向性。

=====================================

注意的是，如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法。
class People｛
public People （String name）｛｝
｝


这种方法名相同，但各自的参数不同，称为方法重载（Overload）。方法重载的返回值类型通常都是相同的。
=====================================

class Person {
    protected String name;
    protected int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Student extends Person { 
protected int score;
public Student(String name, int age, int score) { 
super(name, age); // 调用父类的构造方法this.score = score;
 }
 }
如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。


Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student
会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，
因为子类功能比父类多，多的功能无法凭空变出来。


因此，继承是is关系，组合是has关系。
即Student可以持有一个Book实例.


方法的重写override，体现在多态上。子类对父类的方法进行重写（方法名，参数，返回类型不能变），能动态调用具体实例的方法。
Person  s =new Student()
s是一个实际类型为Student，引用类型为Person的变量

声明时，引用类型仅占栈的小空间，实例后把对象放在堆上。动态调用的是堆上对象的方法，不是引用类型的。


继承可以允许子类覆写父类的方法。
如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final

如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法
class Person { 
public abstract void run();
}

编译器会告诉我们，无法编译Person类，因为它包含抽象方法。
必须把Person类本身也声明为abstract，才能正确编译它


因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。
使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类。

因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。

例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法


面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。

如果一个抽象类没有字段，所有方法全部都是抽象方法， 就可以把该抽象类改写为接口interface。

所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。
因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。

interface Person {
 void run(); 
String getName(); 
}

当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子：

class Student implements Person { 
private String name;
public Student(String name) { 
this.name = name; 
} 
@Override
public void run(){ 
System.out.println(this.name + " run");
 } 
@Override 
public String getName() { 
return this.name; 
} 
}
在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface

一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。

interface Hello {
 void hello();
 } 

interface Person extends Hello {
 void run();
 String getName(); 
}

Person接口现在实际上有3个抽象方法签名。


在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象。
List list = new ArrayList(); 
// 用List接口引用具体子类的实例


静态变量，静态方法属于类class。 
静态字段属于所有实例“共享”的字段
可以通过 
类.静态变量  访问修改。
类.静态方法  调用。


因为interface是不能定义字段的，但可以定义静态常量：
public static final号 float PI =3.1415926
(可以省略 public static final)


public interface Person { 
// 编译器会自动加上public statc final
int MALE = 1; 
int FEMALE = 2;
 }
